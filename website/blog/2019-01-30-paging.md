---
title: GraphQL - Paging
author: Michael Staib
authorURL: https://github.com/michaelstaib
authorImageURL: https://avatars1.githubusercontent.com/u/9714350?s=100&v=4
---

Paging is one of the common problems that you face in the backend no matter if you are using REST or GraphQL. With relayjs Facebook introduced a few server specifications that introduced a way to elegantly to paging.

<!--truncate-->

With version 0.7.0 of Hot Chocolate we are introducing support for the [**relay cursor connections specification**](https://facebook.github.io/relay/graphql/connections.htm).

In order to make paging as simple as possible we have implemented a field middleware that handles implements the paging algorithms specified in the spec when you are using `IQueryable<T>` or `IEnumerable<T>`.

This means if you are using the mongo driver or entity framework or anything else providing the ability to query the database through `IQueryable<T>` then we can safe you a lot of work. If you want to implement paging with store procedures or by other means than you still can use our middleware by implementing `IConnectionResolver`.

##Â Setting things up

Let's have a look at an example with a mongo database. Before we can start let us create a mini server project with our dotnet-cli template.

If you do not have the template installed do so by executing the following command:

```bash
dotnet new -i HotChocolate.Templates.Server
```

Next, let`s create a server:

```bash
mkdir paging
cd paging
dotnet new graphql-server
```

Now, that we have a base project let us add the mongo driver so we can access a database.

```bash
dotnet add package MongoDB.Driver
```

The last thing to setup before we can start adding some code is a mongo database itself. For me the easiest thing to do that is by using docker. If you don't have docker or do not want to use it you can install mongo from here: [https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community).

If you have docker installed, start docker and execute the following command:

```bash
docker run --name mongo -p 27017:27017 -d mongo mongod
```

## Adding some entities

So, since we now have setup everything we can start creating a littel schema. OK, let`s assume we have a small service like twitter where you can post small messages. Our schema could look like the following.

```graphql
type Query {
  messages: [Message!]
}

type Mutation {
  sendMessage(message: MessageInput!): MessagePayload
}

type Message {
  id: ID!
  text: String!
  created: DateTime!
  favorites: Int!
  postedBy: User!
}

input MessageInput {
  userId: ID!
  text: String!
}

type MessagePayload {
  postedMessage: Message
  createdBy: User
}

type User {
  id: ID!
  name: String!
}
```

The problem with the above schema is that after a view posted messages each request to our service would get bigger and slower until we run into timeouts. What we want here is to be able to get chunks of the message stream. Moreover, with this kinds of services we do not really care on which result page we are or so on. If you head over to twitter you instantly recongnise that you can scroll infinitely.

Facebook solves this paging problem with a cursor based baging solution. This means that each entry has a cursor that describes the position in the set as well as the state of the set. This way we can create a paging solution that stays consisten without entries jumping from one page to the next.

So, with the relay approach we have to introduce three new types:

- Connection
  The connection represents our current set that we have selected.

- Edge
  The edge provides us with the cursor of an entry and a pointer to that entry.

- PageInfo
  The page info carries information about the page that we are consuming of the whole set.

With these types our schema would change to the following:

```graphql

```

OK, let us get started by adding some c# code :)

First, we need a class called `Message` and a class `User`:

```csharp
public class Message
{
    public ObjectId Id { get; set; }
    public string Text { get; set; }
    public DateTimeOffset Created { get; set; }
    public int Favorites { get; set; }
    public ObjectId UserId { get; set; }
}

public class User
{
    public ObjectId Id { get; set; }
    public string Name { get; set; }
}
```

Since we are using mongo and this is a simple example we just use the `ObjectId` class provided by mongo.

Now, that we have entities we need to create some kind of a repository that lets us pull messages from the database and create messages.

```csharp
public class MessageRepository
{
    private readonly IMongoCollection<Message> _messageCollection;

    public MessageRepository(IMongoCollection<Message> messageCollection)
    {
        _messageCollection = messageCollection
            ?? throw new ArgumentNullException(nameof(messageCollection));
    }

    public IQueryable<Message> GetAllMessages()
    {
        return _messageCollection.AsQueryable();
    }

    public Task CreateMessageAsync(Message message, CancellationToken cancellationToken)
    {
        return _messageCollection.InsertOneAsync(message, new InsertOneOptions(), cancellationToken);
    }
}

public class UserRepository
{
    private readonly IMongoCollection<User> _userCollection;

    public UserRepository(IMongoCollection<User> userCollection)
    {
        _userCollection = userCollection
            ?? throw new ArgumentNullException(nameof(userCollection));
    }

    public IQueryable<User> GetAllUsers()
    {
        return _userCollection.AsQueryable();
    }

    public Task<User> GetUserAsync(ObjectId userId, CancellationToken cancellationToken)
    {
        return _userCollection.Find(c => c.Id == userId)
            .FirstOrDefaultAsync(cancellationToken);
    }

    public Task CreateUserAsync(User user, CancellationToken cancellationToken)
    {
        return _userCollection.InsertOneAsync(user, new InsertOneOptions(), cancellationToken);
    }
}
```

The message repository can create new messages and basically get `IQueryable<Message>` to query the database. It is important to know that `_messageCollection.AsQueryable();` did not yet execute anything on the database. The queryable interface lets us basically create a query that we than at alter point can execute. The user repository has additionally a method to get a user by it's id.

The database interaction is for now settled, let us move now to setting up our schema. Hot Chocolate allows you to create schemas by providing a schema SDL like the one that I used earlier to clarify how our schema will look like, or you can use schema-types which we also call the code-first approach. You also could go with pocos but of this post I will use our code-first approach.

So, first let us model our object types for message and user.

```csharp
public class MessageType
    : ObjectType<Message>
{
    protected override void Configure(IObjectTypeDescriptor<Message> descriptor)
    {
        descriptor.Field(t => t.Id).Type<NonNullType<IdType>>();
        descriptor.Field(t => t.Text).Type<NonNullType<StringType>>();
        descriptor.Field(t => t.UserId).Type<NonNullType<IdType>>();
    }
}

public class UserType
    : ObjectType<User>
{
    protected override void Configure(IObjectTypeDescriptor<User> descriptor)
    {
        descriptor.Field(t => t.Id).Type<NonNullType<IdType>>();
        descriptor.Field(t => t.Name).Type<NonNullType<StringType>>();
    }
}
```

Hot Chocolate can infer a lot from the entity type, however there are things like non-nullability on reference types that have to be specified. Moreover, the ID type cannot be detected since it is basically string base and used to tell the consumer of the schema what fields are identifiers.

Next, we have to specify our two root types `Query` and `Mutation`. The query type is fairly simple:

```csharp
public class QueryType
    : ObjectType
{
    protected override void Configure(IObjectTypeDescriptor descriptor)
    {
        descriptor.Field("messages")
            .UsePaging<MessageType>()
            .Resolver(ctx => ctx.Service<MessageRepository>().GetAllMessages());
    }
}
```

So, lets have a closer look at our field declaration, first we specify the name, and that we just say `UsePaging` and lastly we specify a resolver that is getting a queryable. The magic here is hidden behind `UsePaging`. `UsePaging` specifies all the paging arguments, the return type of the messages field and adds a paging field middleware. This means that in most cases we do not have to bother about implementing the paging logic.

The mutation type is a little bit more complex since we
